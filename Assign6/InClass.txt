typdef struct pl_TRANS{
    uint32_t unused:16;
    uint32_t pagno:8;
    unit32_t offset:8;
} pl_TRANS;

pl_TRANS VM
vm.pasglno;

typdef union{
    unit32_t ul;
    pl_TRANS bf;
} U_PLTRANS

U_PLTRANS u_addr;

read(fd, &addr, 4);
u_addr ul = addr;

TLB 16 elements
Page table of 256 elements
frame list (0-256)

go to tlb first address is not there, translate it and grab it from the disk
- get a frame number
- first access is 0, next is 1, through 255
- frame 0 is mapped just like memory


crete a struture in memory (65k)
create another strcutre that is (16 elements) 
- 2 ints (page number, frame number)

typedef struct {
    int page_num;
    int frame_num;
} TLB

TLB tlb[16];

int pg_nums[256];

0x4214
0x42 (66) 0x14 (20)

check tlb for 66, if not check pg_nums
if not in pg_nums, go check memory and get it from backing_store

go to frame 66 to get it, fseek(66 x 256) (how many bits to go)
read in the frame 
find a free frame using free frame list (0-...)
take it from backing_store into physical memory 
    read it using buffer[256]
    take next free frame (0) (impment using anything) (incrememnt)
updated tlb 
    pg_66 stored in frame 0


last Step:
- asking for offset byte
    - you go to the 20th byte and print whats ever there



next ex.

0xF41D
F4(244) 1D(29)
check tlb, look for pg 244 if not there
go to pg table, look for pg 244
grab from physical memory (244*256)
page 244 -> next free frame (frame 1)
update pg table to show 244 is in frame 1
update tlb (2nd entry pg244 = frame 1)
    - tlb can only hold 16
    - if tlb is full get a victim frame using LRU 
grab the 29th byte and print 


to test go to backing_store and check the byte 
OD (object DUMB)

typecast the byte to read it